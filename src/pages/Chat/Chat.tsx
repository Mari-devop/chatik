import React, { useState, useEffect, useCallback, useRef } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import axios from "axios";
import { dbInstance } from "../../db";
import { validateToken } from "../../utils/authUtils";
import { ChatProps, Message } from "./types";
import { User } from "../../components/menu/types";
import {
  ChatContainer,
  PersonContainer,
  PersonBox,
  Title,
  Subtitle,
  TextBox,
  DialogContainer,
  RespondContainer,
  QuestionContainer,
  Question,
  Text,
  AnswerBox,
  Respond,
  RespondBox,
  TextRespond,
  Icon,
  Social,
  IconSocial,
  PersonShadow,
  PersonPhoto,
  IconBox,
  PersonAnswer,
  InputBox,
  Input,
  InputWrapper,
  Button,
} from "./Chat.styled";
import ModalSuccess from "../../components/ModalSuccess/ModalSuccess";
import LoadingDots from "../../components/LoadingDots/LoadingDots";
import shadow from "../../assets/images/chat/shadow.png";
import share from "../../assets/images/chat/Frame 143725072.png";
import profile from "../../assets/images/profile-user.png";

const Chat: React.FC<ChatProps> = ({ isAuthenticated }) => {
  const location = useLocation();
  const navigate = useNavigate();
  const individual = location.state;
  const {
    individualId,
    response: initialResponse,
    name,
    title,
  } = location.state;
  const [scrolled, setScrolled] = useState(false);
  const [filteredResponses, setFilteredResponses] = useState<any[]>(
    location.state.filteredResponses || []
  );
  const [currentResponse, setCurrentResponse] = useState<string | null>(
    initialResponse
  );
  const [userImage, setUserImage] = useState<string>(profile);
  const [message, setMessage] = useState<string>("");
  const [isGrowing, setIsGrowing] = useState(false);
  const [chatHistory, setChatHistory] = useState<Message[]>([]);
  const [questionVisible, setQuestionVisible] = useState(true);
  const [isDialogStarted, setIsDialogStarted] = useState(false);
  const [wasQuestionClicked, setWasQuestionClicked] = useState(false);
  const [showModal, setShowModal] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [modalType, setModalType] = useState<"success" | "failure">("success");
  const [modalMessage, setModalMessage] = useState("");
  const [userIsScrolling, setUserIsScrolling] = useState(false);
  const answerBoxRef = useRef<HTMLDivElement | null>(null);
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);

  const handleInputClick = () => {
    if (!isAuthenticated) {
      setModalMessage("Please login to use this feature.");
      setShowModal(true);
    }
  };

  useEffect(() => {
    const fetchUserData = async () => {
      const users = await dbInstance.getData("users");
      const lastUser = users[users.length - 1];
      if (lastUser?.image) {
        setUserImage(lastUser.image || profile);
      }
    };
    fetchUserData();
  }, []);

  const handleShare = async (text: string, individualId: number) => {
    try {
      const individuals = await dbInstance.getData("individuals");
      const individual = individuals.find(
        (ind: any) => ind.id === individualId
      );
      const individualName = individual?.name || "Shared Response";
      const fullMessage = `${text}\n\nGenerated by ${window.location.origin}`;

      if (navigator.share) {
        const shareText = `Response from ${individualName}:\n\n${text}\n\nGenerated by ${window.location.origin}`;

        navigator
          .share({
            text: shareText,
          })
          .then(() => console.log("Successfully shared!"))
          .catch((error) => console.error("Error sharing:", error));
      } else {
        navigator.clipboard.writeText(fullMessage).then(
          () => {
            alert(`Response from ${individualName} copied to clipboard!`);
          },
          (error) => {
            console.error("Could not copy text: ", error);
          }
        );
      }
    } catch (error) {
      console.error("Error fetching individual name:", error);
    }
  };

  useEffect(() => {
    const { filteredResponses } = location.state;

    if (!filteredResponses || filteredResponses.length === 0) {
      console.warn("No filtered responses available");
    }
  }, [location.state]);

  const fetchSmallImageForResponse = async (individualId: number) => {
    const individuals = await dbInstance.getData("individuals");
    const individual = individuals.find((ind: any) => ind.id === individualId);
    return individual?.smallImage || profile;
  };

  useEffect(() => {
    const loadImagesForResponses = async () => {
      const updatedResponses = await Promise.all(
        filteredResponses.map(async (resp: any) => {
          const smallImage = await fetchSmallImageForResponse(
            resp.individualId
          );
          return { ...resp, smallImage };
        })
      );
      setFilteredResponses(updatedResponses);
    };

    if (filteredResponses.length > 0) {
      loadImagesForResponses();
    }
  }, [location.state.filteredResponses]);

  const handleScroll = (e: Event) => {
    const target = e.target as HTMLElement;
    const top = target.scrollTop;
    const height = target.scrollHeight - target.clientHeight;
    setScrolled(top > 0);

    if (top < height - 100) {
      setUserIsScrolling(true);
    } else {
      setUserIsScrolling(false);
    }
  };

  useEffect(() => {
    const scrollContainer = document.getElementById("scrollContainer");
    if (scrollContainer) {
      scrollContainer.addEventListener("scroll", handleScroll);
    }

    return () => {
      if (scrollContainer) {
        scrollContainer.removeEventListener("scroll", handleScroll);
      }
    };
  }, []);

  useEffect(() => {
    if (!userIsScrolling && answerBoxRef.current) {
      answerBoxRef.current.scrollIntoView({ behavior: "smooth" });
    }
  }, [filteredResponses, chatHistory]);

  const breakLongWords = (message: string, maxLength: number = 32): string => {
    return message
      .split(" ")
      .map((word) => {
        if (word.length > maxLength) {
          const brokenWord =
            word.match(new RegExp(`.{1,${maxLength}}`, "g"))?.join("\n") ||
            word;
          return brokenWord;
        }
        return word;
      })
      .join(" ");
  };

  const simulateResponse = async (response: string) => {
    setCurrentResponse(null); 
    await new Promise((resolve) => setTimeout(resolve, 2000)); 
    setCurrentResponse(response); 
  
    await new Promise((resolve) => setTimeout(resolve, 2000)); 
    setChatHistory((prev) => [
      ...prev,
      { text: response, isUser: false, smallImage: individual?.smallImage || profile },
    ]);
  

    setCurrentResponse(null);
    setIsDialogStarted(false); 
    setQuestionVisible(false); 
  };
  

  const handleSendMessage = async () => {
    if (!message.trim() || isLoading) return;

    try {
      const users = await dbInstance.getData("users");
      const lastUser = users[users.length - 1];
      const token = lastUser?.token;

      if (!token) {
        setModalType("failure");
        setModalMessage("Your session has expired. Please login again.");
        setShowModal(true);

        setTimeout(() => {
          setShowModal(false);
          navigate("/");
        }, 3000);
        return;
      }

      const tokenIsValid = await validateToken();
      if (!tokenIsValid) {
        setModalType("failure");
        setModalMessage("Your session has expired. Please login again.");
        setShowModal(true);

        setTimeout(() => {
          setShowModal(false);
          navigate("/");
        }, 3000);
        return;
      }

      setIsLoading(true);
      setIsDialogStarted(true);

      const formattedMessage = breakLongWords(message, 32);

      if (currentResponse) {
        setChatHistory((prev) => [
          ...prev,
          {
            text: currentResponse,
            isUser: false,
            smallImage: individual?.smallImage || profile,
          },
        ]);
      }

      setChatHistory((prev) => [
        ...prev,
        {
          text: formattedMessage,
          isUser: true,
          smallImage: userImage || profile,
        },
      ]);

      setMessage("");

      const body = {
        characterId: individualId,
        message: formattedMessage,
      };

      const response = await axios.post(
        "https://eternalai.fly.dev/api/chat",
        body,
        {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
        }
      );
      await simulateResponse(response.data.response);
      const smallImage = await fetchSmallImageForResponse(individualId);

      // setPreviousResponse(currentResponse);
      // setCurrentResponse(response.data.response);

      setIsLoading(false);
      answerBoxRef.current?.scrollIntoView({ behavior: "smooth" });

      const input = document.querySelector("textarea") as HTMLTextAreaElement;
      if (input) {
        input.style.height = "auto";
      }

      setIsGrowing(false);

      setQuestionVisible(false);
      setIsLoading(false);
    } catch (error: any) {
      setIsLoading(false);
      console.error("Error sending message:", error);

      if (error.response?.status === 401) {
        console.error(
          "Token is expired or invalid, deleting token and redirecting to login..."
        );

        try {
          const users = await dbInstance.getData("users");
          const tokensToDelete: number[] = [];

          users.forEach((user: User) => {
            if (user.token) {
              tokensToDelete.push(user.id);
            }
          });

          for (const userId of tokensToDelete) {
            await dbInstance.deleteData("users", userId);
          }

          setModalType("failure");
          setModalMessage("Your session has expired. Please login again.");
          setShowModal(true);

          setTimeout(() => {
            setShowModal(false);
            navigate("/");
          }, 3000);
        } catch (deleteError) {
          console.error("Error deleting token:", deleteError);
        }
      }
      if (
        error.response?.status === 500 &&
        error.response?.data?.message.includes(
          "Please subscribe to use this feature"
        )
      ) {
        setShowModal(true);
        setTimeout(() => {
          setShowModal(false);
          navigate("/paywall");
        }, 3000);
      }
    }
  };

  const fetchAllChatHistory = useCallback(async () => {
    if (!individualId) return;

    try {
      const users = await dbInstance.getData("users");
      const lastUser = users[users.length - 1];
      const userToken = lastUser?.token;

      if (!userToken) {
        console.error("Token is missing or user is not authenticated");
        return;
      }

      let allChatHistory: Message[] = [];
      let page = 1;
      let totalPages = 1;

      while (page <= totalPages) {
        const response = await axios.get(
          `https://eternalai.fly.dev/api/chatHistory/${individualId}?page=${page}`,
          {
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${userToken}`,
            },
          }
        );

        const { chat, totalPages: fetchedTotalPages } =
          response.data.chatHistory;
        totalPages = fetchedTotalPages;

        const updatedChatHistory = await Promise.all(
          chat.map(async (entry: any) => {
            const smallImage = await fetchSmallImageForResponse(individualId);
            return {
              isUser: entry.sender === "user",
              text: entry.content,
              smallImage:
                entry.sender === "user"
                  ? lastUser.image || profile
                  : smallImage,
            };
          })
        );

        allChatHistory = [...allChatHistory, ...updatedChatHistory];

        page += 1;
      }

      setChatHistory(allChatHistory);
    } catch (error) {
      console.error("Error fetching chat history:", error);
    }
  }, [individualId, userImage]);

  useEffect(() => {
    if (individual) {
      fetchAllChatHistory();
    }
  }, [individual, fetchAllChatHistory]);

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    const target = e.target as HTMLTextAreaElement;

    if (e.key === "Enter") {
      if (e.shiftKey) {
        e.preventDefault();

        const { selectionStart, selectionEnd } = target;

        const newValue =
          message.slice(0, selectionStart) + "\n" + message.slice(selectionEnd);
        setMessage(newValue);

        setTimeout(() => {
          target.style.height = "auto";
          target.style.height = `${target.scrollHeight}px`;
        }, 0);
      } else {
        e.preventDefault();

        handleSendMessage();
        setMessage("");
        target.style.height = "auto";
      }
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setMessage(e.target.value);
    e.target.style.height = "auto";
    e.target.style.height = `${e.target.scrollHeight}px`;
    setIsGrowing(e.target.scrollHeight > 45);
    setQuestionVisible(false);
  };

  const handleInputFocus = () => {
    setQuestionVisible(false);
  };

  const handleQuestionClick = () => {
    setWasQuestionClicked(true);
  };

  return (
    <>
      <ModalSuccess
        isVisible={showModal}
        modalType="failure"
        message="Please subscribe to use this feature"
        onClose={() => setShowModal(false)}
      />

      <ChatContainer>
        <PersonContainer>
          <PersonBox>
            <PersonShadow src={shadow} />
            <PersonPhoto src={individual?.fullImage || ""} />
            <TextBox>
              <Title>{name || individual?.name}</Title>
              <Subtitle>{title || individual?.title}</Subtitle>
            </TextBox>
          </PersonBox>
        </PersonContainer>
        <DialogContainer>
          <RespondContainer>
            <AnswerBox id="scrollContainer" ref={scrollContainerRef}>
              {(isDialogStarted || !!individual?.questionText) && (
                <Question
                  $isVisible={questionVisible && !!individual?.questionText}
                  onClick={handleQuestionClick}
                >
                  <Text>{individual?.questionText}</Text>
                </Question>
              )}
              {filteredResponses.length > 0 &&
                filteredResponses.map((resp: any, index: number) => (
                  <Respond key={index}>
                    <IconBox>
                      <Icon src={resp?.smallImage || profile} />
                    </IconBox>
                    <RespondBox>
                      <TextRespond>
                        {resp?.text || "No response available"}
                      </TextRespond>
                      <Social>
                        <IconSocial
                          src={share}
                          onClick={() =>
                            handleShare(resp?.text, resp?.individualId)
                          }
                        />
                      </Social>
                    </RespondBox>
                  </Respond>
                ))}

              {chatHistory.length > 0 &&
                chatHistory.map((chat, index) => (
                  <Respond key={index}>
                    <IconBox>
                      <Icon
                        src={
                          chat.isUser
                            ? chat.smallImage
                            : individual?.smallImage || profile
                        }
                      />
                    </IconBox>
                    <RespondBox>
                      <TextRespond>{chat.text}</TextRespond>
                      <Social>
                        <IconSocial
                          src={share}
                          onClick={() =>
                            handleShare(
                              chat?.text,
                              chat?.isUser ? 0 : individualId
                            )
                          }
                        />
                      </Social>
                    </RespondBox>
                  </Respond>
                ))}
              <div ref={answerBoxRef} />
            </AnswerBox>
          </RespondContainer>
          <QuestionContainer>
            {isDialogStarted && (
              <PersonAnswer>
                <Text>{currentResponse || <LoadingDots />}</Text>
              </PersonAnswer>
            )}
          </QuestionContainer>
          <InputBox>
            <InputWrapper isGrowing={isGrowing} onClick={handleInputClick}>
              <Input
                as="textarea"
                placeholder="Enter your message..."
                style={{ pointerEvents: isAuthenticated ? "auto" : "none" }}
                value={message}
                onChange={handleInputChange}
                onFocus={handleInputFocus}
                onKeyDown={handleKeyDown}
                rows={1}
                isGrowing={isGrowing}
              />
            </InputWrapper>
            <Button onClick={handleSendMessage} disabled={!isAuthenticated}>
              SUBMIT
            </Button>
          </InputBox>
        </DialogContainer>
      </ChatContainer>
    </>
  );
};

export default Chat;
